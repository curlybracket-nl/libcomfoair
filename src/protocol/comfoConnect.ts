// @generated by protobuf-ts 2.9.4 with parameter ts_nocheck
// @generated from protobuf file "comfoConnect.proto" (syntax proto3)
// tslint:disable
// @ts-nocheck
import type { BinaryWriteOptions } from '@protobuf-ts/runtime';
import type { IBinaryWriter } from '@protobuf-ts/runtime';
import { WireType } from '@protobuf-ts/runtime';
import type { BinaryReadOptions } from '@protobuf-ts/runtime';
import type { IBinaryReader } from '@protobuf-ts/runtime';
import { UnknownFieldHandler } from '@protobuf-ts/runtime';
import type { PartialMessage } from '@protobuf-ts/runtime';
import { reflectionMergePartial } from '@protobuf-ts/runtime';
import { MessageType } from '@protobuf-ts/runtime';
/**
 * @generated from protobuf message GatewayDiscovery
 */
export interface GatewayDiscovery {
    /**
     * @generated from protobuf field: GatewayDiscovery.Request request = 1;
     */
    request?: GatewayDiscovery_Request;
    /**
     * @generated from protobuf field: GatewayDiscovery.Response response = 2;
     */
    response?: GatewayDiscovery_Response;
}
/**
 * @generated from protobuf message GatewayDiscovery.Request
 */
export interface GatewayDiscovery_Request {}
/**
 * @generated from protobuf message GatewayDiscovery.Response
 */
export interface GatewayDiscovery_Response {
    /**
     * @generated from protobuf field: string address = 1;
     */
    address: string;
    /**
     * @generated from protobuf field: bytes uuid = 2;
     */
    uuid: Uint8Array;
    /**
     * @generated from protobuf field: uint32 version = 3;
     */
    version: number;
}
/**
 * @generated from protobuf message GatewayOperation
 */
export interface GatewayOperation {
    /**
     * @generated from protobuf field: Opcode opcode = 1;
     */
    opcode: Opcode;
    /**
     * @generated from protobuf field: optional Result result = 2;
     */
    result?: Result;
    /**
     * @generated from protobuf field: optional string description = 3;
     */
    description?: string;
    /**
     * @generated from protobuf field: uint32 id = 4;
     */
    id: number;
}
/**
 * @generated from protobuf message RegisterDeviceRequest
 */
export interface RegisterDeviceRequest {
    /**
     * @generated from protobuf field: bytes uuid = 1;
     */
    uuid: Uint8Array;
    /**
     * @generated from protobuf field: optional uint32 pin = 2;
     */
    pin?: number;
    /**
     * @generated from protobuf field: string deviceName = 3;
     */
    deviceName: string;
}
/**
 * @generated from protobuf message StartSessionRequest
 */
export interface StartSessionRequest {
    /**
     * @generated from protobuf field: optional bool takeover = 1;
     */
    takeover?: boolean;
}
/**
 * @generated from protobuf message StartSessionConfirm
 */
export interface StartSessionConfirm {
    /**
     * @generated from protobuf field: string deviceName = 1;
     */
    deviceName: string;
    /**
     * @generated from protobuf field: bool resumed = 2;
     */
    resumed: boolean;
}
/**
 * @generated from protobuf message CnNodeNotification
 */
export interface CnNodeNotification {
    /**
     * @generated from protobuf field: uint32 nodeId = 1;
     */
    nodeId: number;
    /**
     * @generated from protobuf field: uint32 productId = 2;
     */
    productId: number;
    /**
     * @generated from protobuf field: uint32 zoneId = 3;
     */
    zoneId: number;
    /**
     * @generated from protobuf field: CnNodeNotification.NodeModeType mode = 4;
     */
    mode: CnNodeNotification_NodeModeType;
}
/**
 * @generated from protobuf enum CnNodeNotification.NodeModeType
 */
export enum CnNodeNotification_NodeModeType {
    /**
     * @generated from protobuf enum value: NODE_LEGACY = 0;
     */
    NODE_LEGACY = 0,
    /**
     * @generated from protobuf enum value: NODE_OFFLINE = 1;
     */
    NODE_OFFLINE = 1,
    /**
     * @generated from protobuf enum value: NODE_NORMAL = 2;
     */
    NODE_NORMAL = 2,
    /**
     * @generated from protobuf enum value: NODE_UPDATE = 3;
     */
    NODE_UPDATE = 3,
}
/**
 * @generated from protobuf message CnAlarmNotification
 */
export interface CnAlarmNotification {
    /**
     * @generated from protobuf field: uint32 zone = 1;
     */
    zone: number;
    /**
     * @generated from protobuf field: uint32 productId = 2;
     */
    productId: number;
    /**
     * @generated from protobuf field: uint32 productVariant = 3;
     */
    productVariant: number;
    /**
     * @generated from protobuf field: string serialNumber = 4;
     */
    serialNumber: string;
    /**
     * @generated from protobuf field: uint32 swProgramVersion = 5;
     */
    swProgramVersion: number;
    /**
     * @generated from protobuf field: bytes errors = 6;
     */
    errors: Uint8Array;
    /**
     * @generated from protobuf field: uint32 errorId = 7;
     */
    errorId: number;
    /**
     * @generated from protobuf field: uint32 nodeId = 8;
     */
    nodeId: number;
}
/**
 * @generated from protobuf message VersionConfirm
 */
export interface VersionConfirm {
    /**
     * @generated from protobuf field: uint32 gatewayVersion = 1;
     */
    gatewayVersion: number;
    /**
     * @generated from protobuf field: string serialNumber = 2;
     */
    serialNumber: string;
    /**
     * @generated from protobuf field: uint32 comfoNetVersion = 3;
     */
    comfoNetVersion: number;
}
/**
 * @generated from protobuf message CnTimeRequest
 */
export interface CnTimeRequest {
    /**
     * @generated from protobuf field: optional uint32 setTime = 1;
     */
    setTime?: number;
}
/**
 * @generated from protobuf message CnTimeConfirm
 */
export interface CnTimeConfirm {
    /**
     * @generated from protobuf field: uint32 currentTime = 1;
     */
    currentTime: number;
}
/**
 * @generated from protobuf message CnRpdoRequest
 */
export interface CnRpdoRequest {
    /**
     * @generated from protobuf field: uint32 pdid = 1;
     */
    pdid: number;
    /**
     * @generated from protobuf field: optional uint32 zone = 2;
     */
    zone?: number; // default = 255;
    /**
     * @generated from protobuf field: uint32 type = 3;
     */
    type: number;
    /**
     * @generated from protobuf field: optional uint32 timeout = 4;
     */
    timeout?: number; // default = 4294967295;
}
/**
 * @generated from protobuf message CnRpdoNotification
 */
export interface CnRpdoNotification {
    /**
     * @generated from protobuf field: uint32 pdid = 1;
     */
    pdid: number;
    /**
     * @generated from protobuf field: bytes data = 2;
     */
    data: Uint8Array;
}
/**
 * @generated from protobuf message CnRmiRequest
 */
export interface CnRmiRequest {
    /**
     * @generated from protobuf field: uint32 nodeId = 1;
     */
    nodeId: number;
    /**
     * @generated from protobuf field: bytes message = 2;
     */
    message: Uint8Array;
}
/**
 * @generated from protobuf message CnRmiResponse
 */
export interface CnRmiResponse {
    /**
     * @generated from protobuf field: uint32 result = 1;
     */
    result: number;
    /**
     * @generated from protobuf field: bytes message = 2;
     */
    message: Uint8Array;
}
/**
 * @generated from protobuf message CnRmiAsyncRequest
 */
export interface CnRmiAsyncRequest {
    /**
     * @generated from protobuf field: uint32 nodeId = 1;
     */
    nodeId: number;
    /**
     * @generated from protobuf field: bytes message = 2;
     */
    message: Uint8Array;
}
/**
 * @generated from protobuf message CnRmiAsyncConfirm
 */
export interface CnRmiAsyncConfirm {
    /**
     * @generated from protobuf field: uint32 result = 1;
     */
    result: number;
}
/**
 * @generated from protobuf message CnRmiAsyncResponse
 */
export interface CnRmiAsyncResponse {
    /**
     * @generated from protobuf field: uint32 result = 1;
     */
    result: number;
    /**
     * @generated from protobuf field: bytes message = 2;
     */
    message: Uint8Array;
}
/**
 * @generated from protobuf message NullMessage
 */
export interface NullMessage {}
/**
 * @generated from protobuf enum Opcode
 */
export enum Opcode {
    /**
     * @generated from protobuf enum value: NO_OPERATION = 0;
     */
    NO_OPERATION = 0,
    /**
     * @generated from protobuf enum value: SET_ADDRESS_REQUEST = 1;
     */
    SET_ADDRESS_REQUEST = 1,
    /**
     * @generated from protobuf enum value: REGISTER_DEVICE_REQUEST = 2;
     */
    REGISTER_DEVICE_REQUEST = 2,
    /**
     * @generated from protobuf enum value: START_SESSION_REQUEST = 3;
     */
    START_SESSION_REQUEST = 3,
    /**
     * @generated from protobuf enum value: CLOSE_SESSION_REQUEST = 4;
     */
    CLOSE_SESSION_REQUEST = 4,
    /**
     * @generated from protobuf enum value: LIST_REGISTERED_APPS_REQUEST = 5;
     */
    LIST_REGISTERED_APPS_REQUEST = 5,
    /**
     * @generated from protobuf enum value: UNREGISTER_DEVICE_REQUEST = 6;
     */
    UNREGISTER_DEVICE_REQUEST = 6,
    /**
     * @generated from protobuf enum value: CHANGE_PIN_REQUEST = 7;
     */
    CHANGE_PIN_REQUEST = 7,
    /**
     * @generated from protobuf enum value: GET_REMOTE_ACCESS_ID_REQUEST = 8;
     */
    GET_REMOTE_ACCESS_ID_REQUEST = 8,
    /**
     * @generated from protobuf enum value: SET_REMOTE_ACCESS_ID_REQUEST = 9;
     */
    SET_REMOTE_ACCESS_ID_REQUEST = 9,
    /**
     * @generated from protobuf enum value: GET_SUPPORT_ID_REQUEST = 10;
     */
    GET_SUPPORT_ID_REQUEST = 10,
    /**
     * @generated from protobuf enum value: SET_SUPPORT_ID_REQUEST = 11;
     */
    SET_SUPPORT_ID_REQUEST = 11,
    /**
     * @generated from protobuf enum value: GET_WEB_ID_REQUEST = 12;
     */
    GET_WEB_ID_REQUEST = 12,
    /**
     * @generated from protobuf enum value: SET_WEB_ID_REQUEST = 13;
     */
    SET_WEB_ID_REQUEST = 13,
    /**
     * @generated from protobuf enum value: SET_PUSH_ID_REQUEST = 14;
     */
    SET_PUSH_ID_REQUEST = 14,
    /**
     * @generated from protobuf enum value: DEBUG_REQUEST = 15;
     */
    DEBUG_REQUEST = 15,
    /**
     * @generated from protobuf enum value: UPGRADE_REQUEST = 16;
     */
    UPGRADE_REQUEST = 16,
    /**
     * @generated from protobuf enum value: SET_DEVICE_SETTINGS_REQUEST = 17;
     */
    SET_DEVICE_SETTINGS_REQUEST = 17,
    /**
     * @generated from protobuf enum value: VERSION_REQUEST = 18;
     */
    VERSION_REQUEST = 18,
    /**
     * @generated from protobuf enum value: SET_ADDRESS_CONFIRM = 51;
     */
    SET_ADDRESS_CONFIRM = 51,
    /**
     * @generated from protobuf enum value: REGISTER_DEVICE_CONFIRM = 52;
     */
    REGISTER_DEVICE_CONFIRM = 52,
    /**
     * @generated from protobuf enum value: START_SESSION_CONFIRM = 53;
     */
    START_SESSION_CONFIRM = 53,
    /**
     * @generated from protobuf enum value: CLOSE_SESSION_CONFIRM = 54;
     */
    CLOSE_SESSION_CONFIRM = 54,
    /**
     * @generated from protobuf enum value: LIST_REGISTERED_APPS_CONFIRM = 55;
     */
    LIST_REGISTERED_APPS_CONFIRM = 55,
    /**
     * @generated from protobuf enum value: UNREGISTER_DEVICE_CONFIRM = 56;
     */
    UNREGISTER_DEVICE_CONFIRM = 56,
    /**
     * @generated from protobuf enum value: CHANGE_PIN_CONFIRM = 57;
     */
    CHANGE_PIN_CONFIRM = 57,
    /**
     * @generated from protobuf enum value: GET_REMOTE_ACCESS_ID_CONFIRM = 58;
     */
    GET_REMOTE_ACCESS_ID_CONFIRM = 58,
    /**
     * @generated from protobuf enum value: SET_REMOTE_ACCESS_ID_CONFIRM = 59;
     */
    SET_REMOTE_ACCESS_ID_CONFIRM = 59,
    /**
     * @generated from protobuf enum value: GET_SUPPORT_ID_CONFIRM = 60;
     */
    GET_SUPPORT_ID_CONFIRM = 60,
    /**
     * @generated from protobuf enum value: SET_SUPPORT_ID_CONFIRM = 61;
     */
    SET_SUPPORT_ID_CONFIRM = 61,
    /**
     * @generated from protobuf enum value: GET_WEB_ID_CONFIRM = 62;
     */
    GET_WEB_ID_CONFIRM = 62,
    /**
     * @generated from protobuf enum value: SET_WEB_ID_CONFIRM = 63;
     */
    SET_WEB_ID_CONFIRM = 63,
    /**
     * @generated from protobuf enum value: SET_PUSH_ID_CONFIRM = 64;
     */
    SET_PUSH_ID_CONFIRM = 64,
    /**
     * @generated from protobuf enum value: DEBUG_CONFIRM = 65;
     */
    DEBUG_CONFIRM = 65,
    /**
     * @generated from protobuf enum value: UPGRADE_CONFIRM = 66;
     */
    UPGRADE_CONFIRM = 66,
    /**
     * @generated from protobuf enum value: SET_DEVICE_SETTINGS_CONFIRM = 67;
     */
    SET_DEVICE_SETTINGS_CONFIRM = 67,
    /**
     * @generated from protobuf enum value: VERSION_CONFIRM = 68;
     */
    VERSION_CONFIRM = 68,
    /**
     * @generated from protobuf enum value: GATEWAY_NOTIFICATION = 100;
     */
    GATEWAY_NOTIFICATION = 100,
    /**
     * @generated from protobuf enum value: KEEP_ALIVE = 101;
     */
    KEEP_ALIVE = 101,
    /**
     * @generated from protobuf enum value: FACTORY_RESET = 102;
     */
    FACTORY_RESET = 102,
    /**
     * @generated from protobuf enum value: CN_TIME_REQUEST = 30;
     */
    CN_TIME_REQUEST = 30,
    /**
     * @generated from protobuf enum value: CN_TIME_CONFIRM = 31;
     */
    CN_TIME_CONFIRM = 31,
    /**
     * @generated from protobuf enum value: CN_NODE_REQUEST = 42;
     */
    CN_NODE_REQUEST = 42,
    /**
     * @generated from protobuf enum value: CN_NODE_NOTIFICATION = 32;
     */
    CN_NODE_NOTIFICATION = 32,
    /**
     * @generated from protobuf enum value: CN_RMI_REQUEST = 33;
     */
    CN_RMI_REQUEST = 33,
    /**
     * @generated from protobuf enum value: CN_RMI_RESPONSE = 34;
     */
    CN_RMI_RESPONSE = 34,
    /**
     * @generated from protobuf enum value: CN_RMI_ASYNC_REQUEST = 35;
     */
    CN_RMI_ASYNC_REQUEST = 35,
    /**
     * @generated from protobuf enum value: CN_RMI_ASYNC_CONFIRM = 36;
     */
    CN_RMI_ASYNC_CONFIRM = 36,
    /**
     * @generated from protobuf enum value: CN_RMI_ASYNC_RESPONSE = 37;
     */
    CN_RMI_ASYNC_RESPONSE = 37,
    /**
     * @generated from protobuf enum value: CN_RPDO_REQUEST = 38;
     */
    CN_RPDO_REQUEST = 38,
    /**
     * @generated from protobuf enum value: CN_RPDO_CONFIRM = 39;
     */
    CN_RPDO_CONFIRM = 39,
    /**
     * @generated from protobuf enum value: CN_RPDO_NOTIFICATION = 40;
     */
    CN_RPDO_NOTIFICATION = 40,
    /**
     * @generated from protobuf enum value: CN_ALARM_NOTIFICATION = 41;
     */
    CN_ALARM_NOTIFICATION = 41,
    /**
     * @generated from protobuf enum value: CN_FUP_READ_REGISTER_REQUEST = 70;
     */
    CN_FUP_READ_REGISTER_REQUEST = 70,
    /**
     * @generated from protobuf enum value: CN_FUP_READ_REGISTER_CONFIRM = 71;
     */
    CN_FUP_READ_REGISTER_CONFIRM = 71,
    /**
     * @generated from protobuf enum value: CN_FUP_PROGRAM_BEGIN_REQUEST = 72;
     */
    CN_FUP_PROGRAM_BEGIN_REQUEST = 72,
    /**
     * @generated from protobuf enum value: CN_FUP_PROGRAM_BEGIN_CONFIRM = 73;
     */
    CN_FUP_PROGRAM_BEGIN_CONFIRM = 73,
    /**
     * @generated from protobuf enum value: CN_FUP_PROGRAM_REQUEST = 74;
     */
    CN_FUP_PROGRAM_REQUEST = 74,
    /**
     * @generated from protobuf enum value: CN_FUP_PROGRAM_CONFIRM = 75;
     */
    CN_FUP_PROGRAM_CONFIRM = 75,
    /**
     * @generated from protobuf enum value: CN_FUP_PROGRAM_END_REQUEST = 76;
     */
    CN_FUP_PROGRAM_END_REQUEST = 76,
    /**
     * @generated from protobuf enum value: CN_FUP_PROGRAM_END_CONFIRM = 77;
     */
    CN_FUP_PROGRAM_END_CONFIRM = 77,
    /**
     * @generated from protobuf enum value: CN_FUP_READ_REQUEST = 78;
     */
    CN_FUP_READ_REQUEST = 78,
    /**
     * @generated from protobuf enum value: CN_FUP_READ_CONFIRM = 79;
     */
    CN_FUP_READ_CONFIRM = 79,
    /**
     * @generated from protobuf enum value: CN_FUP_RESET_REQUEST = 80;
     */
    CN_FUP_RESET_REQUEST = 80,
    /**
     * @generated from protobuf enum value: CN_FUP_RESET_CONFIRM = 81;
     */
    CN_FUP_RESET_CONFIRM = 81,
}
/**
 * @generated from protobuf enum Result
 */
export enum Result {
    /**
     * @generated from protobuf enum value: OK = 0;
     */
    OK = 0,
    /**
     * @generated from protobuf enum value: BAD_REQUEST = 1;
     */
    BAD_REQUEST = 1,
    /**
     * @generated from protobuf enum value: INTERNAL_ERROR = 2;
     */
    INTERNAL_ERROR = 2,
    /**
     * @generated from protobuf enum value: NOT_REACHABLE = 3;
     */
    NOT_REACHABLE = 3,
    /**
     * @generated from protobuf enum value: OTHER_SESSION = 4;
     */
    OTHER_SESSION = 4,
    /**
     * @generated from protobuf enum value: NOT_ALLOWED = 5;
     */
    NOT_ALLOWED = 5,
    /**
     * @generated from protobuf enum value: NO_RESOURCES = 6;
     */
    NO_RESOURCES = 6,
    /**
     * @generated from protobuf enum value: NOT_EXIST = 7;
     */
    NOT_EXIST = 7,
    /**
     * @generated from protobuf enum value: RMI_ERROR = 8;
     */
    RMI_ERROR = 8,
}
// @generated message type with reflection information, may provide speed optimized methods
class GatewayDiscovery$Type extends MessageType<GatewayDiscovery> {
    constructor() {
        super('GatewayDiscovery', [
            { no: 1, name: 'request', kind: 'message', T: () => GatewayDiscovery_Request },
            { no: 2, name: 'response', kind: 'message', T: () => GatewayDiscovery_Response },
        ]);
    }
    create(value?: PartialMessage<GatewayDiscovery>): GatewayDiscovery {
        const message = globalThis.Object.create(this.messagePrototype!);
        if (value !== undefined) reflectionMergePartial<GatewayDiscovery>(this, message, value);
        return message;
    }
    internalBinaryRead(
        reader: IBinaryReader,
        length: number,
        options: BinaryReadOptions,
        target?: GatewayDiscovery,
    ): GatewayDiscovery {
        let message = target ?? this.create(),
            end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* GatewayDiscovery.Request request */ 1:
                    message.request = GatewayDiscovery_Request.internalBinaryRead(
                        reader,
                        reader.uint32(),
                        options,
                        message.request,
                    );
                    break;
                case /* GatewayDiscovery.Response response */ 2:
                    message.response = GatewayDiscovery_Response.internalBinaryRead(
                        reader,
                        reader.uint32(),
                        options,
                        message.response,
                    );
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === 'throw')
                        throw new globalThis.Error(
                            `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`,
                        );
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: GatewayDiscovery, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* GatewayDiscovery.Request request = 1; */
        if (message.request)
            GatewayDiscovery_Request.internalBinaryWrite(
                message.request,
                writer.tag(1, WireType.LengthDelimited).fork(),
                options,
            ).join();
        /* GatewayDiscovery.Response response = 2; */
        if (message.response)
            GatewayDiscovery_Response.internalBinaryWrite(
                message.response,
                writer.tag(2, WireType.LengthDelimited).fork(),
                options,
            ).join();
        let u = options.writeUnknownFields;
        if (u !== false) (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message GatewayDiscovery
 */
export const GatewayDiscovery = new GatewayDiscovery$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GatewayDiscovery_Request$Type extends MessageType<GatewayDiscovery_Request> {
    constructor() {
        super('GatewayDiscovery.Request', []);
    }
    create(value?: PartialMessage<GatewayDiscovery_Request>): GatewayDiscovery_Request {
        const message = globalThis.Object.create(this.messagePrototype!);
        if (value !== undefined) reflectionMergePartial<GatewayDiscovery_Request>(this, message, value);
        return message;
    }
    internalBinaryRead(
        reader: IBinaryReader,
        length: number,
        options: BinaryReadOptions,
        target?: GatewayDiscovery_Request,
    ): GatewayDiscovery_Request {
        return target ?? this.create();
    }
    internalBinaryWrite(
        message: GatewayDiscovery_Request,
        writer: IBinaryWriter,
        options: BinaryWriteOptions,
    ): IBinaryWriter {
        let u = options.writeUnknownFields;
        if (u !== false) (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message GatewayDiscovery.Request
 */
export const GatewayDiscovery_Request = new GatewayDiscovery_Request$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GatewayDiscovery_Response$Type extends MessageType<GatewayDiscovery_Response> {
    constructor() {
        super('GatewayDiscovery.Response', [
            { no: 1, name: 'address', kind: 'scalar', T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: 'uuid', kind: 'scalar', T: 12 /*ScalarType.BYTES*/ },
            { no: 3, name: 'version', kind: 'scalar', T: 13 /*ScalarType.UINT32*/ },
        ]);
    }
    create(value?: PartialMessage<GatewayDiscovery_Response>): GatewayDiscovery_Response {
        const message = globalThis.Object.create(this.messagePrototype!);
        message.address = '';
        message.uuid = new Uint8Array(0);
        message.version = 0;
        if (value !== undefined) reflectionMergePartial<GatewayDiscovery_Response>(this, message, value);
        return message;
    }
    internalBinaryRead(
        reader: IBinaryReader,
        length: number,
        options: BinaryReadOptions,
        target?: GatewayDiscovery_Response,
    ): GatewayDiscovery_Response {
        let message = target ?? this.create(),
            end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string address */ 1:
                    message.address = reader.string();
                    break;
                case /* bytes uuid */ 2:
                    message.uuid = reader.bytes();
                    break;
                case /* uint32 version */ 3:
                    message.version = reader.uint32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === 'throw')
                        throw new globalThis.Error(
                            `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`,
                        );
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(
        message: GatewayDiscovery_Response,
        writer: IBinaryWriter,
        options: BinaryWriteOptions,
    ): IBinaryWriter {
        /* string address = 1; */
        if (message.address !== '') writer.tag(1, WireType.LengthDelimited).string(message.address);
        /* bytes uuid = 2; */
        if (message.uuid.length) writer.tag(2, WireType.LengthDelimited).bytes(message.uuid);
        /* uint32 version = 3; */
        if (message.version !== 0) writer.tag(3, WireType.Varint).uint32(message.version);
        let u = options.writeUnknownFields;
        if (u !== false) (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message GatewayDiscovery.Response
 */
export const GatewayDiscovery_Response = new GatewayDiscovery_Response$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GatewayOperation$Type extends MessageType<GatewayOperation> {
    constructor() {
        super('GatewayOperation', [
            { no: 1, name: 'opcode', kind: 'enum', T: () => ['Opcode', Opcode] },
            { no: 2, name: 'result', kind: 'enum', opt: true, T: () => ['Result', Result] },
            { no: 3, name: 'description', kind: 'scalar', opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 4, name: 'id', kind: 'scalar', T: 13 /*ScalarType.UINT32*/ },
        ]);
    }
    create(value?: PartialMessage<GatewayOperation>): GatewayOperation {
        const message = globalThis.Object.create(this.messagePrototype!);
        message.opcode = 0;
        message.id = 0;
        if (value !== undefined) reflectionMergePartial<GatewayOperation>(this, message, value);
        return message;
    }
    internalBinaryRead(
        reader: IBinaryReader,
        length: number,
        options: BinaryReadOptions,
        target?: GatewayOperation,
    ): GatewayOperation {
        let message = target ?? this.create(),
            end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* Opcode opcode */ 1:
                    message.opcode = reader.int32();
                    break;
                case /* optional Result result */ 2:
                    message.result = reader.int32();
                    break;
                case /* optional string description */ 3:
                    message.description = reader.string();
                    break;
                case /* uint32 id */ 4:
                    message.id = reader.uint32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === 'throw')
                        throw new globalThis.Error(
                            `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`,
                        );
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: GatewayOperation, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* Opcode opcode = 1; */
        if (message.opcode !== 0) writer.tag(1, WireType.Varint).int32(message.opcode);
        /* optional Result result = 2; */
        if (message.result !== undefined) writer.tag(2, WireType.Varint).int32(message.result);
        /* optional string description = 3; */
        if (message.description !== undefined) writer.tag(3, WireType.LengthDelimited).string(message.description);
        /* uint32 id = 4; */
        if (message.id !== 0) writer.tag(4, WireType.Varint).uint32(message.id);
        let u = options.writeUnknownFields;
        if (u !== false) (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message GatewayOperation
 */
export const GatewayOperation = new GatewayOperation$Type();
// @generated message type with reflection information, may provide speed optimized methods
class RegisterDeviceRequest$Type extends MessageType<RegisterDeviceRequest> {
    constructor() {
        super('RegisterDeviceRequest', [
            { no: 1, name: 'uuid', kind: 'scalar', T: 12 /*ScalarType.BYTES*/ },
            { no: 2, name: 'pin', kind: 'scalar', opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 3, name: 'deviceName', kind: 'scalar', T: 9 /*ScalarType.STRING*/ },
        ]);
    }
    create(value?: PartialMessage<RegisterDeviceRequest>): RegisterDeviceRequest {
        const message = globalThis.Object.create(this.messagePrototype!);
        message.uuid = new Uint8Array(0);
        message.deviceName = '';
        if (value !== undefined) reflectionMergePartial<RegisterDeviceRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(
        reader: IBinaryReader,
        length: number,
        options: BinaryReadOptions,
        target?: RegisterDeviceRequest,
    ): RegisterDeviceRequest {
        let message = target ?? this.create(),
            end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* bytes uuid */ 1:
                    message.uuid = reader.bytes();
                    break;
                case /* optional uint32 pin */ 2:
                    message.pin = reader.uint32();
                    break;
                case /* string deviceName */ 3:
                    message.deviceName = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === 'throw')
                        throw new globalThis.Error(
                            `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`,
                        );
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(
        message: RegisterDeviceRequest,
        writer: IBinaryWriter,
        options: BinaryWriteOptions,
    ): IBinaryWriter {
        /* bytes uuid = 1; */
        if (message.uuid.length) writer.tag(1, WireType.LengthDelimited).bytes(message.uuid);
        /* optional uint32 pin = 2; */
        if (message.pin !== undefined) writer.tag(2, WireType.Varint).uint32(message.pin);
        /* string deviceName = 3; */
        if (message.deviceName !== '') writer.tag(3, WireType.LengthDelimited).string(message.deviceName);
        let u = options.writeUnknownFields;
        if (u !== false) (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message RegisterDeviceRequest
 */
export const RegisterDeviceRequest = new RegisterDeviceRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class StartSessionRequest$Type extends MessageType<StartSessionRequest> {
    constructor() {
        super('StartSessionRequest', [
            { no: 1, name: 'takeover', kind: 'scalar', opt: true, T: 8 /*ScalarType.BOOL*/ },
        ]);
    }
    create(value?: PartialMessage<StartSessionRequest>): StartSessionRequest {
        const message = globalThis.Object.create(this.messagePrototype!);
        if (value !== undefined) reflectionMergePartial<StartSessionRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(
        reader: IBinaryReader,
        length: number,
        options: BinaryReadOptions,
        target?: StartSessionRequest,
    ): StartSessionRequest {
        let message = target ?? this.create(),
            end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional bool takeover */ 1:
                    message.takeover = reader.bool();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === 'throw')
                        throw new globalThis.Error(
                            `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`,
                        );
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(
        message: StartSessionRequest,
        writer: IBinaryWriter,
        options: BinaryWriteOptions,
    ): IBinaryWriter {
        /* optional bool takeover = 1; */
        if (message.takeover !== undefined) writer.tag(1, WireType.Varint).bool(message.takeover);
        let u = options.writeUnknownFields;
        if (u !== false) (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message StartSessionRequest
 */
export const StartSessionRequest = new StartSessionRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class StartSessionConfirm$Type extends MessageType<StartSessionConfirm> {
    constructor() {
        super('StartSessionConfirm', [
            { no: 1, name: 'deviceName', kind: 'scalar', T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: 'resumed', kind: 'scalar', T: 8 /*ScalarType.BOOL*/ },
        ]);
    }
    create(value?: PartialMessage<StartSessionConfirm>): StartSessionConfirm {
        const message = globalThis.Object.create(this.messagePrototype!);
        message.deviceName = '';
        message.resumed = false;
        if (value !== undefined) reflectionMergePartial<StartSessionConfirm>(this, message, value);
        return message;
    }
    internalBinaryRead(
        reader: IBinaryReader,
        length: number,
        options: BinaryReadOptions,
        target?: StartSessionConfirm,
    ): StartSessionConfirm {
        let message = target ?? this.create(),
            end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string deviceName */ 1:
                    message.deviceName = reader.string();
                    break;
                case /* bool resumed */ 2:
                    message.resumed = reader.bool();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === 'throw')
                        throw new globalThis.Error(
                            `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`,
                        );
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(
        message: StartSessionConfirm,
        writer: IBinaryWriter,
        options: BinaryWriteOptions,
    ): IBinaryWriter {
        /* string deviceName = 1; */
        if (message.deviceName !== '') writer.tag(1, WireType.LengthDelimited).string(message.deviceName);
        /* bool resumed = 2; */
        if (message.resumed !== false) writer.tag(2, WireType.Varint).bool(message.resumed);
        let u = options.writeUnknownFields;
        if (u !== false) (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message StartSessionConfirm
 */
export const StartSessionConfirm = new StartSessionConfirm$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CnNodeNotification$Type extends MessageType<CnNodeNotification> {
    constructor() {
        super('CnNodeNotification', [
            { no: 1, name: 'nodeId', kind: 'scalar', T: 13 /*ScalarType.UINT32*/ },
            { no: 2, name: 'productId', kind: 'scalar', T: 13 /*ScalarType.UINT32*/ },
            { no: 3, name: 'zoneId', kind: 'scalar', T: 13 /*ScalarType.UINT32*/ },
            {
                no: 4,
                name: 'mode',
                kind: 'enum',
                T: () => ['CnNodeNotification.NodeModeType', CnNodeNotification_NodeModeType],
            },
        ]);
    }
    create(value?: PartialMessage<CnNodeNotification>): CnNodeNotification {
        const message = globalThis.Object.create(this.messagePrototype!);
        message.nodeId = 0;
        message.productId = 0;
        message.zoneId = 0;
        message.mode = 0;
        if (value !== undefined) reflectionMergePartial<CnNodeNotification>(this, message, value);
        return message;
    }
    internalBinaryRead(
        reader: IBinaryReader,
        length: number,
        options: BinaryReadOptions,
        target?: CnNodeNotification,
    ): CnNodeNotification {
        let message = target ?? this.create(),
            end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* uint32 nodeId */ 1:
                    message.nodeId = reader.uint32();
                    break;
                case /* uint32 productId */ 2:
                    message.productId = reader.uint32();
                    break;
                case /* uint32 zoneId */ 3:
                    message.zoneId = reader.uint32();
                    break;
                case /* CnNodeNotification.NodeModeType mode */ 4:
                    message.mode = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === 'throw')
                        throw new globalThis.Error(
                            `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`,
                        );
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(
        message: CnNodeNotification,
        writer: IBinaryWriter,
        options: BinaryWriteOptions,
    ): IBinaryWriter {
        /* uint32 nodeId = 1; */
        if (message.nodeId !== 0) writer.tag(1, WireType.Varint).uint32(message.nodeId);
        /* uint32 productId = 2; */
        if (message.productId !== 0) writer.tag(2, WireType.Varint).uint32(message.productId);
        /* uint32 zoneId = 3; */
        if (message.zoneId !== 0) writer.tag(3, WireType.Varint).uint32(message.zoneId);
        /* CnNodeNotification.NodeModeType mode = 4; */
        if (message.mode !== 0) writer.tag(4, WireType.Varint).int32(message.mode);
        let u = options.writeUnknownFields;
        if (u !== false) (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message CnNodeNotification
 */
export const CnNodeNotification = new CnNodeNotification$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CnAlarmNotification$Type extends MessageType<CnAlarmNotification> {
    constructor() {
        super('CnAlarmNotification', [
            { no: 1, name: 'zone', kind: 'scalar', T: 13 /*ScalarType.UINT32*/ },
            { no: 2, name: 'productId', kind: 'scalar', T: 13 /*ScalarType.UINT32*/ },
            { no: 3, name: 'productVariant', kind: 'scalar', T: 13 /*ScalarType.UINT32*/ },
            { no: 4, name: 'serialNumber', kind: 'scalar', T: 9 /*ScalarType.STRING*/ },
            { no: 5, name: 'swProgramVersion', kind: 'scalar', T: 13 /*ScalarType.UINT32*/ },
            { no: 6, name: 'errors', kind: 'scalar', T: 12 /*ScalarType.BYTES*/ },
            { no: 7, name: 'errorId', kind: 'scalar', T: 13 /*ScalarType.UINT32*/ },
            { no: 8, name: 'nodeId', kind: 'scalar', T: 13 /*ScalarType.UINT32*/ },
        ]);
    }
    create(value?: PartialMessage<CnAlarmNotification>): CnAlarmNotification {
        const message = globalThis.Object.create(this.messagePrototype!);
        message.zone = 0;
        message.productId = 0;
        message.productVariant = 0;
        message.serialNumber = '';
        message.swProgramVersion = 0;
        message.errors = new Uint8Array(0);
        message.errorId = 0;
        message.nodeId = 0;
        if (value !== undefined) reflectionMergePartial<CnAlarmNotification>(this, message, value);
        return message;
    }
    internalBinaryRead(
        reader: IBinaryReader,
        length: number,
        options: BinaryReadOptions,
        target?: CnAlarmNotification,
    ): CnAlarmNotification {
        let message = target ?? this.create(),
            end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* uint32 zone */ 1:
                    message.zone = reader.uint32();
                    break;
                case /* uint32 productId */ 2:
                    message.productId = reader.uint32();
                    break;
                case /* uint32 productVariant */ 3:
                    message.productVariant = reader.uint32();
                    break;
                case /* string serialNumber */ 4:
                    message.serialNumber = reader.string();
                    break;
                case /* uint32 swProgramVersion */ 5:
                    message.swProgramVersion = reader.uint32();
                    break;
                case /* bytes errors */ 6:
                    message.errors = reader.bytes();
                    break;
                case /* uint32 errorId */ 7:
                    message.errorId = reader.uint32();
                    break;
                case /* uint32 nodeId */ 8:
                    message.nodeId = reader.uint32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === 'throw')
                        throw new globalThis.Error(
                            `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`,
                        );
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(
        message: CnAlarmNotification,
        writer: IBinaryWriter,
        options: BinaryWriteOptions,
    ): IBinaryWriter {
        /* uint32 zone = 1; */
        if (message.zone !== 0) writer.tag(1, WireType.Varint).uint32(message.zone);
        /* uint32 productId = 2; */
        if (message.productId !== 0) writer.tag(2, WireType.Varint).uint32(message.productId);
        /* uint32 productVariant = 3; */
        if (message.productVariant !== 0) writer.tag(3, WireType.Varint).uint32(message.productVariant);
        /* string serialNumber = 4; */
        if (message.serialNumber !== '') writer.tag(4, WireType.LengthDelimited).string(message.serialNumber);
        /* uint32 swProgramVersion = 5; */
        if (message.swProgramVersion !== 0) writer.tag(5, WireType.Varint).uint32(message.swProgramVersion);
        /* bytes errors = 6; */
        if (message.errors.length) writer.tag(6, WireType.LengthDelimited).bytes(message.errors);
        /* uint32 errorId = 7; */
        if (message.errorId !== 0) writer.tag(7, WireType.Varint).uint32(message.errorId);
        /* uint32 nodeId = 8; */
        if (message.nodeId !== 0) writer.tag(8, WireType.Varint).uint32(message.nodeId);
        let u = options.writeUnknownFields;
        if (u !== false) (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message CnAlarmNotification
 */
export const CnAlarmNotification = new CnAlarmNotification$Type();
// @generated message type with reflection information, may provide speed optimized methods
class VersionConfirm$Type extends MessageType<VersionConfirm> {
    constructor() {
        super('VersionConfirm', [
            { no: 1, name: 'gatewayVersion', kind: 'scalar', T: 13 /*ScalarType.UINT32*/ },
            { no: 2, name: 'serialNumber', kind: 'scalar', T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: 'comfoNetVersion', kind: 'scalar', T: 13 /*ScalarType.UINT32*/ },
        ]);
    }
    create(value?: PartialMessage<VersionConfirm>): VersionConfirm {
        const message = globalThis.Object.create(this.messagePrototype!);
        message.gatewayVersion = 0;
        message.serialNumber = '';
        message.comfoNetVersion = 0;
        if (value !== undefined) reflectionMergePartial<VersionConfirm>(this, message, value);
        return message;
    }
    internalBinaryRead(
        reader: IBinaryReader,
        length: number,
        options: BinaryReadOptions,
        target?: VersionConfirm,
    ): VersionConfirm {
        let message = target ?? this.create(),
            end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* uint32 gatewayVersion */ 1:
                    message.gatewayVersion = reader.uint32();
                    break;
                case /* string serialNumber */ 2:
                    message.serialNumber = reader.string();
                    break;
                case /* uint32 comfoNetVersion */ 3:
                    message.comfoNetVersion = reader.uint32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === 'throw')
                        throw new globalThis.Error(
                            `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`,
                        );
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: VersionConfirm, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* uint32 gatewayVersion = 1; */
        if (message.gatewayVersion !== 0) writer.tag(1, WireType.Varint).uint32(message.gatewayVersion);
        /* string serialNumber = 2; */
        if (message.serialNumber !== '') writer.tag(2, WireType.LengthDelimited).string(message.serialNumber);
        /* uint32 comfoNetVersion = 3; */
        if (message.comfoNetVersion !== 0) writer.tag(3, WireType.Varint).uint32(message.comfoNetVersion);
        let u = options.writeUnknownFields;
        if (u !== false) (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message VersionConfirm
 */
export const VersionConfirm = new VersionConfirm$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CnTimeRequest$Type extends MessageType<CnTimeRequest> {
    constructor() {
        super('CnTimeRequest', [{ no: 1, name: 'setTime', kind: 'scalar', opt: true, T: 13 /*ScalarType.UINT32*/ }]);
    }
    create(value?: PartialMessage<CnTimeRequest>): CnTimeRequest {
        const message = globalThis.Object.create(this.messagePrototype!);
        if (value !== undefined) reflectionMergePartial<CnTimeRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(
        reader: IBinaryReader,
        length: number,
        options: BinaryReadOptions,
        target?: CnTimeRequest,
    ): CnTimeRequest {
        let message = target ?? this.create(),
            end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional uint32 setTime */ 1:
                    message.setTime = reader.uint32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === 'throw')
                        throw new globalThis.Error(
                            `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`,
                        );
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CnTimeRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional uint32 setTime = 1; */
        if (message.setTime !== undefined) writer.tag(1, WireType.Varint).uint32(message.setTime);
        let u = options.writeUnknownFields;
        if (u !== false) (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message CnTimeRequest
 */
export const CnTimeRequest = new CnTimeRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CnTimeConfirm$Type extends MessageType<CnTimeConfirm> {
    constructor() {
        super('CnTimeConfirm', [{ no: 1, name: 'currentTime', kind: 'scalar', T: 13 /*ScalarType.UINT32*/ }]);
    }
    create(value?: PartialMessage<CnTimeConfirm>): CnTimeConfirm {
        const message = globalThis.Object.create(this.messagePrototype!);
        message.currentTime = 0;
        if (value !== undefined) reflectionMergePartial<CnTimeConfirm>(this, message, value);
        return message;
    }
    internalBinaryRead(
        reader: IBinaryReader,
        length: number,
        options: BinaryReadOptions,
        target?: CnTimeConfirm,
    ): CnTimeConfirm {
        let message = target ?? this.create(),
            end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* uint32 currentTime */ 1:
                    message.currentTime = reader.uint32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === 'throw')
                        throw new globalThis.Error(
                            `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`,
                        );
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CnTimeConfirm, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* uint32 currentTime = 1; */
        if (message.currentTime !== 0) writer.tag(1, WireType.Varint).uint32(message.currentTime);
        let u = options.writeUnknownFields;
        if (u !== false) (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message CnTimeConfirm
 */
export const CnTimeConfirm = new CnTimeConfirm$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CnRpdoRequest$Type extends MessageType<CnRpdoRequest> {
    constructor() {
        super('CnRpdoRequest', [
            { no: 1, name: 'pdid', kind: 'scalar', T: 13 /*ScalarType.UINT32*/ },
            { no: 2, name: 'zone', kind: 'scalar', opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 3, name: 'type', kind: 'scalar', T: 13 /*ScalarType.UINT32*/ },
            { no: 4, name: 'timeout', kind: 'scalar', opt: true, T: 13 /*ScalarType.UINT32*/ },
        ]);
    }
    create(value?: PartialMessage<CnRpdoRequest>): CnRpdoRequest {
        const message = globalThis.Object.create(this.messagePrototype!);
        message.pdid = 0;
        message.type = 0;
        if (value !== undefined) reflectionMergePartial<CnRpdoRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(
        reader: IBinaryReader,
        length: number,
        options: BinaryReadOptions,
        target?: CnRpdoRequest,
    ): CnRpdoRequest {
        let message = target ?? this.create(),
            end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* uint32 pdid */ 1:
                    message.pdid = reader.uint32();
                    break;
                case /* optional uint32 zone */ 2:
                    message.zone = reader.uint32();
                    break;
                case /* uint32 type */ 3:
                    message.type = reader.uint32();
                    break;
                case /* optional uint32 timeout */ 4:
                    message.timeout = reader.uint32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === 'throw')
                        throw new globalThis.Error(
                            `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`,
                        );
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CnRpdoRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* uint32 pdid = 1; */
        if (message.pdid !== 0) writer.tag(1, WireType.Varint).uint32(message.pdid);
        /* optional uint32 zone = 2; */
        if (message.zone !== undefined) writer.tag(2, WireType.Varint).uint32(message.zone);
        /* uint32 type = 3; */
        if (message.type !== 0) writer.tag(3, WireType.Varint).uint32(message.type);
        /* optional uint32 timeout = 4; */
        if (message.timeout !== undefined) writer.tag(4, WireType.Varint).uint32(message.timeout);
        let u = options.writeUnknownFields;
        if (u !== false) (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message CnRpdoRequest
 */
export const CnRpdoRequest = new CnRpdoRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CnRpdoNotification$Type extends MessageType<CnRpdoNotification> {
    constructor() {
        super('CnRpdoNotification', [
            { no: 1, name: 'pdid', kind: 'scalar', T: 13 /*ScalarType.UINT32*/ },
            { no: 2, name: 'data', kind: 'scalar', T: 12 /*ScalarType.BYTES*/ },
        ]);
    }
    create(value?: PartialMessage<CnRpdoNotification>): CnRpdoNotification {
        const message = globalThis.Object.create(this.messagePrototype!);
        message.pdid = 0;
        message.data = new Uint8Array(0);
        if (value !== undefined) reflectionMergePartial<CnRpdoNotification>(this, message, value);
        return message;
    }
    internalBinaryRead(
        reader: IBinaryReader,
        length: number,
        options: BinaryReadOptions,
        target?: CnRpdoNotification,
    ): CnRpdoNotification {
        let message = target ?? this.create(),
            end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* uint32 pdid */ 1:
                    message.pdid = reader.uint32();
                    break;
                case /* bytes data */ 2:
                    message.data = reader.bytes();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === 'throw')
                        throw new globalThis.Error(
                            `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`,
                        );
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(
        message: CnRpdoNotification,
        writer: IBinaryWriter,
        options: BinaryWriteOptions,
    ): IBinaryWriter {
        /* uint32 pdid = 1; */
        if (message.pdid !== 0) writer.tag(1, WireType.Varint).uint32(message.pdid);
        /* bytes data = 2; */
        if (message.data.length) writer.tag(2, WireType.LengthDelimited).bytes(message.data);
        let u = options.writeUnknownFields;
        if (u !== false) (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message CnRpdoNotification
 */
export const CnRpdoNotification = new CnRpdoNotification$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CnRmiRequest$Type extends MessageType<CnRmiRequest> {
    constructor() {
        super('CnRmiRequest', [
            { no: 1, name: 'nodeId', kind: 'scalar', T: 13 /*ScalarType.UINT32*/ },
            { no: 2, name: 'message', kind: 'scalar', T: 12 /*ScalarType.BYTES*/ },
        ]);
    }
    create(value?: PartialMessage<CnRmiRequest>): CnRmiRequest {
        const message = globalThis.Object.create(this.messagePrototype!);
        message.nodeId = 0;
        message.message = new Uint8Array(0);
        if (value !== undefined) reflectionMergePartial<CnRmiRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(
        reader: IBinaryReader,
        length: number,
        options: BinaryReadOptions,
        target?: CnRmiRequest,
    ): CnRmiRequest {
        let message = target ?? this.create(),
            end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* uint32 nodeId */ 1:
                    message.nodeId = reader.uint32();
                    break;
                case /* bytes message */ 2:
                    message.message = reader.bytes();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === 'throw')
                        throw new globalThis.Error(
                            `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`,
                        );
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CnRmiRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* uint32 nodeId = 1; */
        if (message.nodeId !== 0) writer.tag(1, WireType.Varint).uint32(message.nodeId);
        /* bytes message = 2; */
        if (message.message.length) writer.tag(2, WireType.LengthDelimited).bytes(message.message);
        let u = options.writeUnknownFields;
        if (u !== false) (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message CnRmiRequest
 */
export const CnRmiRequest = new CnRmiRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CnRmiResponse$Type extends MessageType<CnRmiResponse> {
    constructor() {
        super('CnRmiResponse', [
            { no: 1, name: 'result', kind: 'scalar', T: 13 /*ScalarType.UINT32*/ },
            { no: 2, name: 'message', kind: 'scalar', T: 12 /*ScalarType.BYTES*/ },
        ]);
    }
    create(value?: PartialMessage<CnRmiResponse>): CnRmiResponse {
        const message = globalThis.Object.create(this.messagePrototype!);
        message.result = 0;
        message.message = new Uint8Array(0);
        if (value !== undefined) reflectionMergePartial<CnRmiResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(
        reader: IBinaryReader,
        length: number,
        options: BinaryReadOptions,
        target?: CnRmiResponse,
    ): CnRmiResponse {
        let message = target ?? this.create(),
            end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* uint32 result */ 1:
                    message.result = reader.uint32();
                    break;
                case /* bytes message */ 2:
                    message.message = reader.bytes();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === 'throw')
                        throw new globalThis.Error(
                            `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`,
                        );
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CnRmiResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* uint32 result = 1; */
        if (message.result !== 0) writer.tag(1, WireType.Varint).uint32(message.result);
        /* bytes message = 2; */
        if (message.message.length) writer.tag(2, WireType.LengthDelimited).bytes(message.message);
        let u = options.writeUnknownFields;
        if (u !== false) (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message CnRmiResponse
 */
export const CnRmiResponse = new CnRmiResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CnRmiAsyncRequest$Type extends MessageType<CnRmiAsyncRequest> {
    constructor() {
        super('CnRmiAsyncRequest', [
            { no: 1, name: 'nodeId', kind: 'scalar', T: 13 /*ScalarType.UINT32*/ },
            { no: 2, name: 'message', kind: 'scalar', T: 12 /*ScalarType.BYTES*/ },
        ]);
    }
    create(value?: PartialMessage<CnRmiAsyncRequest>): CnRmiAsyncRequest {
        const message = globalThis.Object.create(this.messagePrototype!);
        message.nodeId = 0;
        message.message = new Uint8Array(0);
        if (value !== undefined) reflectionMergePartial<CnRmiAsyncRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(
        reader: IBinaryReader,
        length: number,
        options: BinaryReadOptions,
        target?: CnRmiAsyncRequest,
    ): CnRmiAsyncRequest {
        let message = target ?? this.create(),
            end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* uint32 nodeId */ 1:
                    message.nodeId = reader.uint32();
                    break;
                case /* bytes message */ 2:
                    message.message = reader.bytes();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === 'throw')
                        throw new globalThis.Error(
                            `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`,
                        );
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CnRmiAsyncRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* uint32 nodeId = 1; */
        if (message.nodeId !== 0) writer.tag(1, WireType.Varint).uint32(message.nodeId);
        /* bytes message = 2; */
        if (message.message.length) writer.tag(2, WireType.LengthDelimited).bytes(message.message);
        let u = options.writeUnknownFields;
        if (u !== false) (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message CnRmiAsyncRequest
 */
export const CnRmiAsyncRequest = new CnRmiAsyncRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CnRmiAsyncConfirm$Type extends MessageType<CnRmiAsyncConfirm> {
    constructor() {
        super('CnRmiAsyncConfirm', [{ no: 1, name: 'result', kind: 'scalar', T: 13 /*ScalarType.UINT32*/ }]);
    }
    create(value?: PartialMessage<CnRmiAsyncConfirm>): CnRmiAsyncConfirm {
        const message = globalThis.Object.create(this.messagePrototype!);
        message.result = 0;
        if (value !== undefined) reflectionMergePartial<CnRmiAsyncConfirm>(this, message, value);
        return message;
    }
    internalBinaryRead(
        reader: IBinaryReader,
        length: number,
        options: BinaryReadOptions,
        target?: CnRmiAsyncConfirm,
    ): CnRmiAsyncConfirm {
        let message = target ?? this.create(),
            end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* uint32 result */ 1:
                    message.result = reader.uint32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === 'throw')
                        throw new globalThis.Error(
                            `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`,
                        );
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CnRmiAsyncConfirm, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* uint32 result = 1; */
        if (message.result !== 0) writer.tag(1, WireType.Varint).uint32(message.result);
        let u = options.writeUnknownFields;
        if (u !== false) (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message CnRmiAsyncConfirm
 */
export const CnRmiAsyncConfirm = new CnRmiAsyncConfirm$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CnRmiAsyncResponse$Type extends MessageType<CnRmiAsyncResponse> {
    constructor() {
        super('CnRmiAsyncResponse', [
            { no: 1, name: 'result', kind: 'scalar', T: 13 /*ScalarType.UINT32*/ },
            { no: 2, name: 'message', kind: 'scalar', T: 12 /*ScalarType.BYTES*/ },
        ]);
    }
    create(value?: PartialMessage<CnRmiAsyncResponse>): CnRmiAsyncResponse {
        const message = globalThis.Object.create(this.messagePrototype!);
        message.result = 0;
        message.message = new Uint8Array(0);
        if (value !== undefined) reflectionMergePartial<CnRmiAsyncResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(
        reader: IBinaryReader,
        length: number,
        options: BinaryReadOptions,
        target?: CnRmiAsyncResponse,
    ): CnRmiAsyncResponse {
        let message = target ?? this.create(),
            end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* uint32 result */ 1:
                    message.result = reader.uint32();
                    break;
                case /* bytes message */ 2:
                    message.message = reader.bytes();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === 'throw')
                        throw new globalThis.Error(
                            `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`,
                        );
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(
        message: CnRmiAsyncResponse,
        writer: IBinaryWriter,
        options: BinaryWriteOptions,
    ): IBinaryWriter {
        /* uint32 result = 1; */
        if (message.result !== 0) writer.tag(1, WireType.Varint).uint32(message.result);
        /* bytes message = 2; */
        if (message.message.length) writer.tag(2, WireType.LengthDelimited).bytes(message.message);
        let u = options.writeUnknownFields;
        if (u !== false) (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message CnRmiAsyncResponse
 */
export const CnRmiAsyncResponse = new CnRmiAsyncResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class NullMessage$Type extends MessageType<NullMessage> {
    constructor() {
        super('NullMessage', []);
    }
    create(value?: PartialMessage<NullMessage>): NullMessage {
        const message = globalThis.Object.create(this.messagePrototype!);
        if (value !== undefined) reflectionMergePartial<NullMessage>(this, message, value);
        return message;
    }
    internalBinaryRead(
        reader: IBinaryReader,
        length: number,
        options: BinaryReadOptions,
        target?: NullMessage,
    ): NullMessage {
        return target ?? this.create();
    }
    internalBinaryWrite(message: NullMessage, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        let u = options.writeUnknownFields;
        if (u !== false) (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message NullMessage
 */
export const NullMessage = new NullMessage$Type();
